<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>EMOJI_ENGINE_PRO_v4.5_ULTRA</title>

<style>
:root {
  --neon-pink:#ff0055;
  --neon-cyan:#00f2ff;
  --terminal-green:#00ff41;
  --bg-black:#050505;
  --panel-border:#222;
}

body{
  background:var(--bg-black);
  color:#fff;
  font-family:monospace;
  margin:0;
}

.app-container{
  max-width:1400px;
  margin:20px auto;
  padding:20px;
  border:1px solid var(--panel-border);
  background:#0a0a0a;
}

.sidebar-layout{
  display:grid;
  grid-template-columns:350px 1fr;
  gap:20px;
  align-items:start;
}

.controls-panel{
  border-right:1px solid var(--panel-border);
  padding-right:15px;
}

.control-item{margin-bottom:15px;}

select,input,button{
  width:100%;
  background:#111;
  border:1px solid #333;
  color:var(--neon-cyan);
  padding:8px;
  margin-top:5px;
}

canvas{
  display:block;
  width:100%;
  border:1px solid #222;
  background:#000;
  image-rendering:pixelated;
}

#emojiCanvas{
  height:auto;
}

#visualizerCanvas{
  height:120px;
  margin-top:10px;
}

video{display:none;}
.warning{color:var(--neon-pink);font-size:0.7rem;}
</style>
</head>
<body>

<div class="app-container">
<h2>> EMOJI_ENGINE_ULTRA_v4.5</h2>

<div class="sidebar-layout">

<div class="controls-panel">

<div class="control-item">
<label>Video Source</label>
<input type="file" id="videoUpload" accept="video/*">
</div>

<div class="control-item">
<label>Pixel Density: <span id="resLabel">12px</span></label>
<input type="range" id="resSlider" min="4" max="50" step="2" value="12">
<div id="resWarning" class="warning" style="display:none">
âš  4px mode is extremely laggy
</div>
</div>

<div class="control-item">
<label>Mapping Algorithm</label>
<select id="emojiMode">
<option value="full">FULL_EMOJI_MATRIX âš  (Very Laggy)</option>
<option value="ascii">ASCII_CLASSIC</option>
<option value="bw">BINARY_SQUARES</option>
<option value="glitch">GLITCH_CORE</option>
<option value="thermal">THERMAL_SIGHT</option>
<option value="ascii_blur">ASCII_BLUR</option>
</select>
</div>

<div class="control-item">
<label>Color Profile</label>
<select id="colorProfile">
<option value="source">SOURCE</option>
<option value="matrix">MATRIX</option>
<option value="cyber">CYBER</option>
<option value="mono">MONO</option>
</select>
</div>

<button id="playBtn">RUN_ENGINE</button>
<button id="exportBtn">EXPORT</button>
<button id="fullscreenStretchBtn">FULLSCREEN STRETCH</button>
<button id="fullscreenFitBtn">FULLSCREEN FIT</button>

</div>

<div>

<canvas id="emojiCanvas"></canvas>
<video id="video"></video>

<canvas id="visualizerCanvas"></canvas>

<div style="margin-top:10px;">
<button id="toggleAudioSource">Use Video Audio</button>
<input type="file" id="audioUpload" accept="audio/*">
<input type="color" id="visColor" value="#00f2ff">
<button id="toggleRainbow">Rainbow OFF</button>
<label>Rainbow Speed</label>
<input type="range" id="rainbowSpeed" min="1" max="30" value="8">

<hr>

<select id="visType">
<option value="bars">Bars</option>
<option value="circle">Circle</option>
<option value="wave">Wave</option>
<option value="energy">Energy</option>
</select>

<label>Bass</label>
<input type="range" id="bassGain" min="0" max="2" step="0.1" value="1">

<label>Mid</label>
<input type="range" id="midGain" min="0" max="2" step="0.1" value="1">

<label>Treble</label>
<input type="range" id="trebleGain" min="0" max="2" step="0.1" value="1">

<label>Warmth (120Hz)</label>
<input type="range" id="warmthGain" min="-12" max="12" step="1" value="0">

<label>Reduce Mud (350Hz)</label>
<input type="range" id="mudGain" min="-12" max="12" step="1" value="0">

<label>Presence (2.5kHz)</label>
<input type="range" id="presenceGain" min="-12" max="12" step="1" value="0">

<label>Air (8kHz)</label>
<input type="range" id="airGain" min="-12" max="12" step="1" value="0">
</div>

</div>
</div>
</div>

<script>

/* ================= RESIZE FIX ================= */
function resizeCanvasToDisplaySize(canvas, ctx) {

  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;

  const displayWidth  = Math.round(rect.width  * dpr);
  const displayHeight = Math.round(rect.height * dpr);

  if (canvas.width !== displayWidth || canvas.height !== displayHeight) {

    canvas.width  = displayWidth;
    canvas.height = displayHeight;

    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);

    return true;
  }

  return false;
}
/* ================= BASIC ENGINE ================= */
const canvas = document.getElementById("emojiCanvas");
const ctx = canvas.getContext("2d", { alpha: false });

const video = document.getElementById("video");
const visCanvas = document.getElementById("visualizerCanvas");
const vCtx = visCanvas.getContext("2d");
const upload = document.getElementById("videoUpload");
const resSlider = document.getElementById("resSlider");
const resLabel = document.getElementById("resLabel");
const resWarning = document.getElementById("resWarning");
const emojiMode = document.getElementById("emojiMode");
const colorProfile = document.getElementById("colorProfile");
let currentResolution = parseInt(resSlider.value);
let isPlaying = false;
let lastFrameData = null;
let currentFontSize = null;
let lastVideoTime = -1;
/* PERFORMANCE CAPS */
const MAX_INTERNAL_WIDTH = 480;   // huge performance boost
const TARGET_FPS = 60;
const FRAME_INTERVAL = 1000 / TARGET_FPS;

/* EMOJIS */
const ASCII_SET=Array.from({length:95},(_,i)=>String.fromCharCode(32+i));
const BW_SET=["â¬›","â¬œ"];
const GLITCH_SET=["?","!","@","#","$","%","X","0","1"];
const THERMAL_SET=["ðŸŸ¦","ðŸŸ©","ðŸŸ¨","ðŸŸ§","ðŸŸ¥"];
const FULL_SET=["â¬›","â¬œ","ðŸŸ¥","ðŸŸ§","ðŸŸ¨","ðŸŸ©","ðŸŸ¦","ðŸ”¥","âœ¨","ðŸŒ‘","ðŸŒ•"];

/* OFFSCREEN */
const offCanvas=new OffscreenCanvas(1,1);
const offCtx=offCanvas.getContext("2d",{willReadFrequently:true});

/* VIDEO LOAD */
upload.onchange=e=>{
video.src=URL.createObjectURL(e.target.files[0]);

video.onloadedmetadata=()=>{

const scale=Math.min(1,MAX_INTERNAL_WIDTH/video.videoWidth);

canvas.width=video.videoWidth;
canvas.height=video.videoHeight;

offCanvas.width=Math.floor(video.videoWidth*scale);
offCanvas.height=Math.floor(video.videoHeight*scale);

visCanvas.width=canvas.width;
visCanvas.height=120;

lastFrameData=null;
};
};

/* RESOLUTION */
resSlider.oninput = () => {
  currentResolution = parseInt(resSlider.value);
  resLabel.textContent = currentResolution + "px";
  resWarning.style.display = currentResolution <= 4 ? "block" : "none";
};
/* ================= RENDER ================= */
if (video.currentTime === lastVideoTime) return;
lastVideoTime = video.currentTime;
function render(size){
if (!video.videoWidth || video.readyState < 2) return;
  resizeCanvasToDisplaySize(canvas, ctx);

/* calculate internal scale */
const scale = Math.min(1, MAX_INTERNAL_WIDTH / video.videoWidth);

const internalWidth  = Math.floor(video.videoWidth * scale);
const internalHeight = Math.floor(video.videoHeight * scale);

/* number of cells */
const cols = Math.floor(internalWidth / size);
const rows = Math.floor(internalHeight / size);
if (cols <= 0 || rows <= 0) return;
/* resize offscreen to grid size */
if(offCanvas.width !== cols || offCanvas.height !== rows){
  offCanvas.width = cols;
  offCanvas.height = rows;
}

/* draw video into grid-sized buffer */
offCtx.drawImage(video, 0, 0, cols, rows);

const imageData = offCtx.getImageData(0,0,cols,rows);
const data = new Uint32Array(imageData.data.buffer);

/* ===== MODE + SCALING FIX ===== */

/* how much grid maps to canvas */
const rect = canvas.getBoundingClientRect();

const cellWidth  = rect.width  / cols;
const cellHeight = rect.height / rows;

/* font must match cell */
const fontSize = Math.max(8, Math.floor(cellHeight));

if(currentFontSize !== fontSize){
  ctx.font = fontSize + "px monospace";
  ctx.textBaseline = "top";
  currentFontSize = fontSize;
}

/* clear once */
ctx.clearRect(0, 0, rect.width, rect.height);
  
if(emojiMode.value === "ascii_blur"){
  ctx.globalAlpha = 0.25;
}

for(let i=0;i<data.length;i++){

  const x = i % cols;
  const y = (i / cols) | 0;

  const p = data[i];
  const r = p & 255;
  const g = (p >> 8) & 255;
  const b = (p >> 16) & 255;

  const bright = (r*0.299 + g*0.587 + b*0.114);
  const norm = bright / 255;

  let char;

  switch(emojiMode.value){

    case "ascii":
    case "ascii_blur": {
      const idx = Math.floor(norm * (ASCII_SET.length - 1));
      char = ASCII_SET[idx];
      break;
    }

    case "bw": {
      char = norm > 0.5 ? BW_SET[1] : BW_SET[0];
      break;
    }

    case "glitch": {
      const shift = (Math.random() * 0.25);
      const idx = Math.floor(
        Math.abs((norm + shift) % 1) * (GLITCH_SET.length - 1)
      );
      char = GLITCH_SET[idx];
      break;
    }

    case "thermal": {
      if(norm < 0.2) char = THERMAL_SET[0];
      else if(norm < 0.4) char = THERMAL_SET[1];
      else if(norm < 0.6) char = THERMAL_SET[2];
      else if(norm < 0.8) char = THERMAL_SET[3];
      else char = THERMAL_SET[4];
      break;
    }

    default: { /* FULL */
      const idx = Math.floor(norm * (FULL_SET.length - 1));
      char = FULL_SET[idx];
    }
  }

  /* color profile */
  if (rainbowEnabled) {
  hue += parseInt(document.getElementById("rainbowSpeed").value) * 0.5;
  ctx.fillStyle = `hsl(${hue % 360},100%,50%)`;
} else {
  ctx.fillStyle =
    colorProfile.value === "matrix" ? `rgb(0,${bright},0)` :
    colorProfile.value === "cyber"  ? `rgb(${bright},0,${bright*0.6})` :
    colorProfile.value === "mono"   ? `rgb(${bright},${bright},${bright})` :
    `rgb(${r},${g},${b})`;
}

  ctx.fillText(char, x * cellWidth, y * cellHeight);
}

ctx.globalAlpha = 1;
}
/* ================= FPS THROTTLED ENGINE LOOP ================= */

let lastTime=0;

function engineLoop(timestamp){

  if(timestamp-lastTime>FRAME_INTERVAL){

    if(isPlaying && !video.paused && !video.ended){
     render(currentResolution);   // â† CHANGE THIS
    }

    lastTime=timestamp;
  }

  requestAnimationFrame(engineLoop);
}

/* ================= AUDIO + VISUALIZER ================= */
/* (unchanged except small optimization) */

let audioCtx;
let analyser;
let source;
let dataArray;

let bassFilter, midFilter, trebleFilter;
let warmthFilter, mudFilter, presenceFilter, airFilter;

const visType=document.getElementById("visType");
const visColor=document.getElementById("visColor");

const bassGain=document.getElementById("bassGain");
const midGain=document.getElementById("midGain");
const trebleGain=document.getElementById("trebleGain");

const warmthGain=document.getElementById("warmthGain");
const mudGain=document.getElementById("mudGain");
const presenceGain=document.getElementById("presenceGain");
const airGain=document.getElementById("airGain");

function initAudio(){
if(audioCtx) return;

audioCtx=new (window.AudioContext||window.webkitAudioContext)();
analyser=audioCtx.createAnalyser();
analyser.fftSize=256;

dataArray=new Uint8Array(analyser.frequencyBinCount);
}

function connectSource(mediaElement){

initAudio();
if(source) source.disconnect();

source=audioCtx.createMediaElementSource(mediaElement);

/* filters */
warmthFilter=audioCtx.createBiquadFilter();
warmthFilter.type="lowshelf";
warmthFilter.frequency.value=120;

mudFilter=audioCtx.createBiquadFilter();
mudFilter.type="peaking";
mudFilter.frequency.value=350;
mudFilter.Q.value=1.2;

presenceFilter=audioCtx.createBiquadFilter();
presenceFilter.type="peaking";
presenceFilter.frequency.value=2500;
presenceFilter.Q.value=1.0;

airFilter=audioCtx.createBiquadFilter();
airFilter.type="highshelf";
airFilter.frequency.value=8000;

bassFilter=audioCtx.createBiquadFilter();
bassFilter.type="lowshelf";
bassFilter.frequency.value=200;

midFilter=audioCtx.createBiquadFilter();
midFilter.type="peaking";
midFilter.frequency.value=1000;

trebleFilter=audioCtx.createBiquadFilter();
trebleFilter.type="highshelf";
trebleFilter.frequency.value=3000;

source
.connect(warmthFilter)
.connect(mudFilter)
.connect(presenceFilter)
.connect(airFilter)
.connect(bassFilter)
.connect(midFilter)
.connect(trebleFilter)
.connect(analyser)
.connect(audioCtx.destination);

updateEQ();
}

function updateEQ(){
if(!bassFilter) return;

bassFilter.gain.value=bassGain.value*10-10;
midFilter.gain.value=midGain.value*10-10;
trebleFilter.gain.value=trebleGain.value*10-10;

warmthFilter.gain.value=warmthGain.value;
mudFilter.gain.value=mudGain.value;
presenceFilter.gain.value=presenceGain.value;
airFilter.gain.value=airGain.value;
}

[bassGain,midGain,trebleGain,
warmthGain,mudGain,presenceGain,airGain]
.forEach(s=>s.oninput=updateEQ);

/* Visualizer */
function drawVisualizer(){
resizeCanvasToDisplaySize(visCanvas, vCtx);
if(!analyser){
requestAnimationFrame(drawVisualizer);
return;
}

const rect = visCanvas.getBoundingClientRect();
const w = rect.width;
const h = rect.height;

vCtx.clearRect(0,0,w,h);

if(visType.value==="wave"){
analyser.getByteTimeDomainData(dataArray);

vCtx.beginPath();
for(let i=0;i<dataArray.length;i++){
const x=(i/dataArray.length)*w;
const y=(dataArray[i]/255)*h;
vCtx.lineTo(x,y);
}
vCtx.strokeStyle=visColor.value;
vCtx.stroke();
}else{
analyser.getByteFrequencyData(dataArray);
const barWidth=w/dataArray.length;

for(let i=0;i<dataArray.length;i++){
const val=dataArray[i];
const barH=(val/255)*h;
vCtx.fillStyle=visColor.value;
vCtx.fillRect(i*barWidth,h-barH,barWidth,barH);
}
}

requestAnimationFrame(drawVisualizer);
}

requestAnimationFrame(drawVisualizer);

video.onplay=()=>connectSource(video);

document.getElementById("playBtn").onclick = () => {

  if (!video.src) return;

  if (video.paused) {
    video.play();
    isPlaying = true;
  } else {
    video.pause();
    isPlaying = false;
  }

};
requestAnimationFrame(engineLoop);
  const audioUpload = document.getElementById("audioUpload");

audioUpload.onchange = e => {
  const file = e.target.files[0];
  if (!file) return;

  const audio = new Audio(URL.createObjectURL(file));
  audio.crossOrigin = "anonymous";
  audio.play();

  connectSource(audio);
};
  let rainbowEnabled = false;
let hue = 0;

const toggleRainbowBtn = document.getElementById("toggleRainbow");

toggleRainbowBtn.onclick = () => {
  rainbowEnabled = !rainbowEnabled;
  toggleRainbowBtn.textContent = rainbowEnabled ? "Rainbow ON" : "Rainbow OFF";
};
/* ================= FULLSCREEN MODES ================= */

const fullscreenStretchBtn = document.getElementById("fullscreenStretchBtn");
const fullscreenFitBtn = document.getElementById("fullscreenFitBtn");
const appContainer = document.querySelector(".app-container");

let fullscreenMode = null;

/* ===== STRETCH MODE (your original behavior) ===== */
fullscreenStretchBtn.onclick = () => {

  fullscreenMode = "stretch";

  if (!document.fullscreenElement) {
    appContainer.requestFullscreen();
  } else {
    document.exitFullscreen();
  }
};

/* ===== FIT MODE (new fixed fullscreen) ===== */
fullscreenFitBtn.onclick = () => {

  fullscreenMode = "fit";

  if (!document.fullscreenElement) {
    appContainer.requestFullscreen();
  } else {
    document.exitFullscreen();
  }
};
document.addEventListener("fullscreenchange", () => {

  if (!document.fullscreenElement) {
    canvas.style.width = "100%";
    canvas.style.height = "auto";
    fullscreenMode = null;
    return;
  }

  if (fullscreenMode === "stretch") {

    canvas.style.width = "100vw";
    canvas.style.height = "100vh";

  } else if (fullscreenMode === "fit") {

    const videoAspect = video.videoWidth / video.videoHeight;
    const screenAspect = window.innerWidth / window.innerHeight;

    if (screenAspect > videoAspect) {
      canvas.style.height = "100vh";
      canvas.style.width = `${100 * videoAspect / screenAspect}vw`;
    } else {
      canvas.style.width = "100vw";
      canvas.style.height = `${100 * screenAspect / videoAspect}vh`;
    }
  }

});

</script>
</body>
</html>
